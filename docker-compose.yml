# This file defines all services that make up the application.
# Run: docker compose up
# Stop: docker compose down
# Rebuild: docker compose up --build

services:
  # --- Django API Server ---
  django:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: production            # Use the production stage
    # env_file loads variables into the container's environment.
    # IMPORTANT: This does NOT copy .env into the image (it's in .dockerignore).
    # Docker Compose reads .env at runtime and injects the values as env vars.
    env_file:
      - ./backend/.env
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings.production
    volumes:
      # Shared volume: Django's collectstatic writes CSS/JS here during build,
      # and Nginx reads from the same volume to serve them. Without this,
      # Nginx's /static/ location would point to an empty directory.
      - static_files:/app/staticfiles
    depends_on:
      db:
        condition: service_healthy  # Wait for PostgreSQL to be ready
      redis:
        condition: service_healthy  # Wait for Redis to be ready
    networks:
      - backend-net

  # --- PostgreSQL Database ---
  db:
    image: postgres:16-alpine       # Alpine = smaller image (~80MB)
    environment:
      POSTGRES_DB: gtdn
      POSTGRES_USER: gtdn_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-changeme}
    volumes:
      - postgres_data:/var/lib/postgresql/data   # Named volume: data persists
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U gtdn_user -d gtdn"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - backend-net

  # --- Redis Cache ---
  # We use Redis ONLY as a cache (not for sessions, queues, or primary data).
  # That means we DON'T need disk persistence (appendonly). If Redis restarts,
  # the cache is empty -- and that's fine, because every cached value can be
  # re-fetched from the external APIs. This saves disk I/O and keeps Redis fast.
  redis:
    image: redis:7-alpine
    command: >
      redis-server
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
      --save ""
    # --maxmemory 256mb: cap RAM usage at 256MB
    # --maxmemory-policy allkeys-lru: when full, evict the least recently used key
    # --save "": disable RDB snapshots (no disk persistence needed for a pure cache)
    # NOTE: If you later add Redis-backed sessions or Celery task queues,
    # re-enable persistence with --appendonly yes and add a redis_data volume.
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - backend-net

  # --- Nginx Reverse Proxy ---
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"                     # The only port exposed to the host
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # Same shared volume: Nginx reads the static files that Django wrote.
      # The :ro flag means Nginx can only READ, not write.
      - static_files:/var/www/static:ro
    depends_on:
      - django
    networks:
      - backend-net

# Named volumes: Docker manages these directories. Data persists across restarts.
# Delete with: docker compose down -v
volumes:
  postgres_data:        # PostgreSQL data -- must persist
  static_files:         # Django collectstatic output, shared with Nginx

# Internal network: containers communicate by service name (e.g., django -> db:5432)
networks:
  backend-net:
    driver: bridge
